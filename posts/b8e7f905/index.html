<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java并发基础1-指令重排序与JVM内存模型 | 小胖吃饭了</title><meta name="keywords" content="Java,并发"><meta name="author" content="ZongweiBai,zongwei.bai@gmail.com"><meta name="copyright" content="ZongweiBai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发是Java重要的一个知识点，在编码的过程中，经常会遇见这样一种场景：单线程下的代码在多线程下出现了和预期不一样的结果，其中一个原因就是JVM对我们的代码做了指令重排序的优化。 一、指令重排序为什么需要对指令进行重排序？其目的就是对我们的代码进行运行上的优化，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发基础1-指令重排序与JVM内存模型">
<meta property="og:url" content="https://zongweibai.github.io/posts/b8e7f905/index.html">
<meta property="og:site_name" content="小胖吃饭了">
<meta property="og:description" content="并发是Java重要的一个知识点，在编码的过程中，经常会遇见这样一种场景：单线程下的代码在多线程下出现了和预期不一样的结果，其中一个原因就是JVM对我们的代码做了指令重排序的优化。 一、指令重排序为什么需要对指令进行重排序？其目的就是对我们的代码进行运行上的优化，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg">
<meta property="article:published_time" content="2022-05-18T01:16:06.990Z">
<meta property="article:modified_time" content="2022-05-19T07:13:50.573Z">
<meta property="article:author" content="ZongweiBai">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zongweibai.github.io/posts/b8e7f905/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-55XE2CFYWJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-55XE2CFYWJ');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"5AQV5VSNTC","apiKey":"60c03791597f87491daa3c33b2ca4fd2","indexName":"zongweibai.github.io","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发基础1-指令重排序与JVM内存模型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-19 15:13:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="小胖吃饭了" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img9.doubanio.com/icon/ul72417058-6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/favorites/"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-cogs"></i><span> 管理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/changes/"><i class="fa-fw fas fa-location-arrow"></i><span> 更新日志</span></a></li><li><a class="site-page child" href="/statistical/"><i class="fa-fw fas fa-globe-asia"></i><span> 站点统计</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小胖吃饭了</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/favorites/"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-cogs"></i><span> 管理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/changes/"><i class="fa-fw fas fa-location-arrow"></i><span> 更新日志</span></a></li><li><a class="site-page child" href="/statistical/"><i class="fa-fw fas fa-globe-asia"></i><span> 站点统计</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发基础1-指令重排序与JVM内存模型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-18T01:16:06.990Z" title="发表于 2022-05-18 09:16:06">2022-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-19T07:13:50.573Z" title="更新于 2022-05-19 15:13:50">2022-05-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%B9%B6%E5%8F%91/">并发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>并发是Java重要的一个知识点，在编码的过程中，经常会遇见这样一种场景：单线程下的代码在多线程下出现了和预期不一样的结果，其中一个原因就是JVM对我们的代码做了指令重排序的优化。</p>
<h1 id="一、指令重排序"><a href="#一、指令重排序" class="headerlink" title="一、指令重排序"></a>一、指令重排序</h1><p><strong>为什么需要对指令进行重排序？</strong>其目的就是对我们的代码进行运行上的优化，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整。</p>
<p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p>
<h2 id="1-1-as-if-serial"><a href="#1-1-as-if-serial" class="headerlink" title="1.1 as-if-serial"></a>1.1 as-if-serial</h2><p>指令重排序必须满足<code>as-if-serial</code>语义：<strong>即无论怎么样重排序，都不能够改变单线程程序运行的结果</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>经过指令重排序后，可能被优化成以下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>1和2的执行顺序被调换，但是不会影响单线程下，执行3获得的结果。</p>
<h2 id="1-2-数据依赖性"><a href="#1-2-数据依赖性" class="headerlink" title="1.2 数据依赖性"></a>1.2 数据依赖性</h2><blockquote>
<p>数据依赖性：如果两个操作同时访问一个变量，且这两个操作中有一个为写操作，那么这两个操作具有数据依赖性。</p>
</blockquote>
<p>数据依赖性：<strong>即无论怎么样重排序，都不能够改变具有数据依赖性的两个操作的执行顺序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> a * <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b;</span><br></pre></td></tr></table></figure>

<p>例如上述代码，不会被重排序调换1和2的位置，因为这两条指令都对a进行了操作，且1对a进行了写操作，存在数据依赖性。</p>
<h2 id="1-3-三种重排序场景"><a href="#1-3-三种重排序场景" class="headerlink" title="1.3 三种重排序场景"></a>1.3 三种重排序场景</h2><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172343124.webp" alt="img"></p>
<p><strong>1、编译器重排序</strong> </p>
<p>针对程序代码语而言，编译器可以在不改变<strong>单线程</strong>程序语义的情况下，可以对代码语句顺序进行调整重新排序。</p>
<p><strong>2、指令集并行的重排序</strong></p>
<p>这个是针对于CPU指令级别来说的，处理器采用了指令集并行技术来讲多条指令重叠执行，如果不存在数据依赖性，处理器可以改变主句对应的机器指令执行顺序。</p>
<p><strong>3、内存重排序</strong> </p>
<p>内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。从表面结果上来看好像指令的顺序被改变了，内存重排序其实是造成可见性问题的主要原因所在。</p>
<p>举个例子，线程 1 修改了 a 的值，但是修改后没有来得及把新结果写回主存或者线程 2 没来得及读到最新的值，所以线程 2 看不到刚才线程 1 对 a 的修改（<strong>也就是说读写操作并不是原子的，这也就是volatile关键字无法保证多线程情况下一致性的原因</strong>），此时线程 2 看到的 a 还是等于初始值。但是线程 2 却可能看到线程 1 修改 a  之后的代码执行效果，表面上看起来像是发生了重顺序。</p>
<h2 id="1-4-重排序对多线程的影响"><a href="#1-4-重排序对多线程的影响" class="headerlink" title="1.4 重排序对多线程的影响"></a>1.4 重排序对多线程的影响</h2><p>单线程的重排序很简单，因为可以通过语义分析就能知道前后代码的依赖性，但是多线程就不一样了，多线程环境里编译器和CPU指令优化根本无法识别多个线程之间存在的数据依赖性，比如说下面的程序代码如果两个方法在两个不同的线程里面调用就可能出现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br><span class="line">    flag=<span class="literal">true</span>;   <span class="comment">//语句2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码，如果程序代码运行都是按顺序的，那么getValue()  中打印的value值必定是等于8的，不过如果init(）方法经过了指令重排序，那么结果就不一定了。根据as-if-serial  原则，init()方法是允许进行指令重排序，因为语句1和语句2之间没有依赖关系。 进行重排序后代码执行顺序可能如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag=<span class="literal">true</span>;   <span class="comment">//语句2  </span></span><br><span class="line">value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br></pre></td></tr></table></figure>

<p>如果init()方法经过了指令重排序后，这个时候两个线程分别调用 init()和getValue()方法，那么就有可能出现下图的情况，导致最终打印出来的value数据等于0。</p>
<p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172328913.png" alt="image-20220517232835679"></p>
<h2 id="1-5-禁止重排序"><a href="#1-5-禁止重排序" class="headerlink" title="1.5 禁止重排序"></a>1.5 禁止重排序</h2><p>在复杂的多线程环境下，编译器和处理器是根本无法通过语义分析来知道代码指令的依赖关系的，所以这个问题只交给能写代码的人才能清楚的知道，这个时候编写代码的人就需要通过一种方式显示的告诉编译器和处理器哪些地方是存在逻辑依赖的，这些地方不能进行重排序。</p>
<p>所以在编译器层面和CPU层面都提供了一套内存屏障来禁止重排序的指令，不过在Java中为了简化开发人员的工作，避免开发人员需要对底层的系统原理的深度理解，所以封装了一套规范，把这些复杂的指令操作与开发人员隔离开来，这就是我们常说的Java 内存模型(JMM)，JMM定义了几个happens  before原则来指导并发程序编写的正确性。程序员可以通过Volatile、synchronized、final几个关键字告诉编译器和处理器哪些地方是不允许进行重排序的。</p>
<h1 id="二、Java内存模型JMM"><a href="#二、Java内存模型JMM" class="headerlink" title="二、Java内存模型JMM"></a>二、Java内存模型JMM</h1><p>Java 内存模型实际上就是规范了 JVM 如何提供按需禁用缓存和重排序优化的方法。其核心就包括volatile、synchronized 和  final 三个关键字，以及几项Happens-Before 规则。有了JMM  作为java的开发人员只需要使用几个关键字(sychronized，volatile，final)，并且理解几个happens  before规则，就能根据自己的需要来禁用缓存优化和指令重排序，从而避免并发问题。</p>
<h2 id="2-1-Happens-Before-原则"><a href="#2-1-Happens-Before-原则" class="headerlink" title="2.1 Happens Before 原则"></a>2.1 Happens Before 原则</h2><p>作为开发人员来说，如果不想太深入底层去了解计算机底层的原理，又想编写出正确的并发程序，那么就必须对Happens Before原则加以理解，理解这些原则才能帮助我们避免并发程序的BUG，在出现并发问题后也能马上发现问题的所在。Happens  Before原则就像我们的JAVA并发程序的开发手册，这个手册中一共包含了X条的原则，下面我们来一一了解。</p>
<blockquote>
<ol>
<li>as-if-serial语义保证了<strong>单线程</strong>内程序的执行结果不会被重排序改变。</li>
<li>happens-before关系保证了<strong>正确同步的多线程程序</strong>的执行结果不会被改变。</li>
<li>happens-before不是规范，而是一种指导思想，我们需要使用各种手段如加锁等实现happens-before，这样才能保证并发环境下结果的正确性。</li>
</ol>
</blockquote>
<h3 id="2-1-1-规则一：程序顺序原则"><a href="#2-1-1-规则一：程序顺序原则" class="headerlink" title="2.1.1 规则一：程序顺序原则"></a>2.1.1 规则一：程序顺序原则</h3><p>定义：在一个线程中，按照程序代码的执行流顺序，先执行的操作happen—before后执行的操作。</p>
<p>说明：这个规则的意思就是 前面的写操作对于后面的读操作来说是可见的，按下面的代码来说，x=1的写入对于flag=true是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    x=<span class="number">1</span>;       <span class="comment">//这里的值对于后续操作可见</span></span><br><span class="line">    flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-规则二：volatile变量规则"><a href="#2-1-2-规则二：volatile变量规则" class="headerlink" title="2.1.2 规则二：volatile变量规则"></a>2.1.2 规则二：volatile变量规则</h3><p>定义：对一个volatile变量的写操作happen—before后面对该变量的读操作。</p>
<p>说明：这个规则的是说，如果一个线程先修改了volatile的变量，那么这个操作对于后续其他线程对这个volatile变量读操作是可见的。 如下代码，线程1调用write() 修改了共享变量 x，然后线程2调用了read() 读取x，这个时候线程1 操作  x=1  对于线程2是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1调用write()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2调用 read()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-规则三：管程中锁的规则"><a href="#2-1-3-规则三：管程中锁的规则" class="headerlink" title="2.1.3 规则三：管程中锁的规则"></a>2.1.3 规则三：管程中锁的规则</h3><p>定义：一个锁的unlock(解锁)操作happen—before后面对该锁的lock(加锁)操作。</p>
<p>说明：如果线程1解锁了A对象，然后线程2对A进行了加锁操作，那么线程1对共享变量的所有写操作对于线程2是可见的。</p>
<p>这个逻辑对应到代码里面就如下,   write()方法 synchronized  代码块执行完之后（也就是对this对象的解锁操作，synchronized代码执行完自动解锁）的结果，对于 read()方法  进入synchronized 代码块(也就是对this对象的加锁操作)是可见的，也就是 代码2 会看到 x=x+1 的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        x=x+<span class="number">1</span>;  <span class="comment">//代码1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        Systemt.out.println(x) <span class="comment">//代码2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-规则四：线程启动规则"><a href="#2-1-4-规则四：线程启动规则" class="headerlink" title="2.1.4 规则四：线程启动规则"></a>2.1.4 规则四：线程启动规则</h3><p>定义：Thread.start()方法happen—before调用用start的线程前的每一个操作。</p>
<p>说明：如果A线程调用 B线程的start()方法，那么A线程 在调用B.start()之前对共享变量的所有写操作对于B线程来说都是可见的。</p>
<p>如下代码，当先运行的线程为线程A，A线程先对共享变量v进行赋值，然后A线程调用B线程start()方法，那么B线程是可以看到v=10的这个操作的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">v=<span class="number">10</span>;   <span class="comment">//此操作对于线程B来说是可见的</span></span><br><span class="line">threadB.start(); <span class="comment">//当前线程调用线程B的start()方法</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-5-规则五：线程终止规则"><a href="#2-1-5-规则五：线程终止规则" class="headerlink" title="2.1.5 规则五：线程终止规则"></a>2.1.5 规则五：线程终止规则</h3><p>定义：线程中的所有操作都happen-before于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值等手段检测到线程已经终止执行。</p>
<p>说明：以join()为例，如果A线程调用B线程的Join()方法，那么当B线程的Join方法返回后，A线程可以看到B线程对共享变量的所有写操作。 以下面代码为例，当前线程调用了threadB的join()方法并返回后，线程设置x=1的操作对于当前线程是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadB.start();</span><br><span class="line">    threadB.join();<span class="comment">//这个操作返回之后，threadB操作 x=1 对于当前线程是可见的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-6-规则六：线程中断规则"><a href="#2-1-6-规则六：线程中断规则" class="headerlink" title="2.1.6 规则六：线程中断规则"></a>2.1.6 规则六：线程中断规则</h3><p>定义：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。</p>
<p>说明：线程A调用了线程B的interrupt()方法，那么当线程B触发interrupt之后，线程A对所有共享变量的写操作对于线程B来说都是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//此处是可以看到 x=1的操作的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadB.start();</span><br><span class="line">    x=<span class="number">1</span>;<span class="comment">//修改共享变量</span></span><br><span class="line">    threadB.interrupt();<span class="comment">//调用threadB中断方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-7-规则七：对象终结规则"><a href="#2-1-7-规则七：对象终结规则" class="headerlink" title="2.1.7 规则七：对象终结规则"></a>2.1.7 规则七：对象终结规则</h3><p>定义：一个对象的初始化完成（构造函数执行结束）happen—before它的<code>finalize()</code>方法的开始。</p>
<p>说明：调用对象<code>finalize()</code>方法时，对象初始化完成的任意操作，对于调用<code>finalize()</code>线程来说都是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception,Throwable&#123;</span><br><span class="line">        Test test=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.finalize(); <span class="comment">//x = 8操作对于此线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-8-规则八：传递性规则"><a href="#2-1-8-规则八：传递性规则" class="headerlink" title="2.1.8 规则八：传递性规则"></a>2.1.8 规则八：传递性规则</h3><p>定义：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。</p>
<p>传递性规则要与其他规则组合理解，以volatile规则+传递性规则为例，下面代码中</p>
<p>1、因为  y=1 hanpen-before  x=2（顺序性原则）</p>
<p>2、而 x = 2 hanpen-before x = 3（volatile变量 规则）; </p>
<p>3、 而x = 3又 hanpen-before  z=4（顺序性原则）。</p>
<p>4、所以最终得出 y=1 happen-before  z=4(传递性原则);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> y; </span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line">    x = <span class="number">2</span>; <span class="comment">//因为 y=1 hanpen-before x=2（顺序性原则） 所以y=1 对于x=2可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">3</span>;  <span class="comment">//因为  x = 2 hanpen-before x=3（volatile 规则） 所以x = 2 对于x=3可见</span></span><br><span class="line">    z=<span class="number">4</span>;  <span class="comment">//因为  y=1 hanpen-before  x=2，而 x = 2 hanpen-before x = 3;  而x = 3又 hanpen-before  z=4（顺序性原则），所以 y=1 happen-before z=4(传递性原则);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Java内存模型"><a href="#2-2-Java内存模型" class="headerlink" title="2.2 Java内存模型"></a>2.2 Java内存模型</h2><p>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。</p>
<ul>
<li>所有的变量都存储在主内存中</li>
<li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li>
</ul>
<p><strong>Java内存模型的作用是控制Java线程之间的通信，它决定了一个线程对共享变量的写入什么时候对另一个线程可见</strong>；而JVM内存模型指的是Java虚拟机运行时的内存分区。这里大家不要混淆。</p>
<p>Java内存模型约定线程之间共享的变量存储在主内存中，而每个线程又有自身私有的本地内存（工作内存），本地内存是Java线程直接能读/写到的区域。 </p>
<p><strong>两条规定:</strong></p>
<ul>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读取</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172346527.png" alt="img"></p>
<p>可以看出，多线程工作的时候，是会从主线程中copy一份副本变量到自己的工作内存，那么如何保证其他线程修改的变量能够被自己的线程读取到，这就是一个缓存可见性的问题。</p>
<h2 id="2-3-缓存的可见性"><a href="#2-3-缓存的可见性" class="headerlink" title="2.3 缓存的可见性"></a>2.3 缓存的可见性</h2><blockquote>
<p>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。</p>
<p>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</p>
</blockquote>
<p> 要实现共享变量的可见性，必须保证两点：</p>
<ul>
<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>
<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</li>
</ul>
<p>产生并发问题的一个核心的原因就是多个CPU都有各自的缓存区域，而且它们各自之间无法感知的，当一个CPU对共享数据进行修改了之后，其它CPU并不知道内容已经被修改了，还是从自己缓存里读取到旧的数据，那么其实解决这个问题的根本其实就是需要一种机制来保证一个人修改了内存数据后另外几个缓存了该共享变量的人可以感知到，那么就可以保证各个缓存之间的数据一致性了。</p>
<h3 id="2-3-1-sychronized"><a href="#2-3-1-sychronized" class="headerlink" title="2.3.1 sychronized"></a>2.3.1 sychronized</h3><p><strong>synchronized 底层实际上通过JVM来实现</strong>的，同一时间只能有一个线程去执行synchronized 中的代码块。</p>
<p>既然<strong>同一时间只有一个线程去运行里面的代码</strong>，那么<strong>这个操作就是不能被其它线程打断的，所以这里天然就具有原子性了。</strong>自然，线程对变量的修改也会被其他线程读取到，可以这里是将并发强行转为了串行。</p>
<p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205180001980.png" alt="image-20220518000131882"></p>
<h3 id="2-3-2-volatile"><a href="#2-3-2-volatile" class="headerlink" title="2.3.2 volatile"></a>2.3.2 volatile</h3><p>volatile起到了如下的作用</p>
<ol>
<li>在对变量进行写入时，会先写入到本地内存然后立即刷新到主内存中；在对变量读取时，直接从主内存读取。</li>
<li>volatile标识的共享变量不会被指令重排序</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205180008126.png" alt="img"></p>
<p>为了达到这两个目的，volatile做了两件事情：</p>
<ol>
<li>禁止编译器的优化和重排</li>
<li>通过内存屏障限制处理器重排</li>
</ol>
<h3 id="2-3-3-内存屏障"><a href="#2-3-3-内存屏障" class="headerlink" title="2.3.3 内存屏障"></a>2.3.3 内存屏障</h3><p>无论是sychronized还是volatile，都是通过内存屏障保证了缓存的可见性。</p>
<p><strong>为什么会有内存屏障？</strong></p>
<ul>
<li>每个CPU都会有自己的缓存(有的甚至有三级缓存)，缓存的目的就是为了提高性能，避免每次都要向内存取，但是这样的弊端也是很明显：不能实时和内存发生信息交换，分在不同CPU执行的不同线程对同一变量的缓存值不同。</li>
<li>用Volatile关键字修饰变量可以解决上述问题，Volatile通过<strong>内存屏障</strong>来实现，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样的，java通过屏蔽这些差异，统一由jvm来生成<strong>内存屏障指令</strong>。</li>
</ul>
<p><strong>内存屏障分为两种</strong></p>
<ul>
<li>Load Barrier 读屏障</li>
<li>Store Barrier 写屏障</li>
</ul>
<p><strong>内存屏障的两个作用</strong></p>
<ul>
<li>阻止屏障两侧的指令重排序</li>
<li>写的时候，强制把缓冲区/高速缓存中的数据写回主内存，并让缓冲中的数据失效；读的时候直接从主内存中读取对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li>
</ul>
<p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</p>
<p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能</p>
<ul>
<li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li>StoreLoad屏障：对于这样的语句Store1; StoreLoad;  Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。<strong>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</strong>。</li>
</ul>
<p><strong>volatile与内存屏障</strong></p>
<p> volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p>
<blockquote>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</p>
<p>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p>
</blockquote>
<p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p>
<h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>对于final域，编译器和CPU会遵循两个排序规则：</p>
<blockquote>
<ol>
<li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</p>
</li>
<li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</p>
</li>
</ol>
</blockquote>
<p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p>
<p>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程CPU可见，并阻止重排序。</p>
<p>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</p>
<p>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zongweibai.github.io">ZongweiBai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zongweibai.github.io/posts/b8e7f905/">https://zongweibai.github.io/posts/b8e7f905/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zongweibai.github.io" target="_blank">小胖吃饭了</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/9a537682/"><img class="prev-cover" src="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发基础2-原子操作</div></div></a></div><div class="next-post pull-right"><a href="/posts/a0ddf6ec/"><img class="next-cover" src="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">国密算法在多语言下的适配</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/9a537682/" title="Java并发基础2-原子操作"><img class="cover" src="https://images.pexels.com/photos/5011647/pexels-photo-5011647.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-19</div><div class="title">Java并发基础2-原子操作</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img9.doubanio.com/icon/ul72417058-6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZongweiBai</div><div class="author-info__description">一个不够纯粹的程序员</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZongweiBai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZongweiBai" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zongwei.bai@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://www.cnblogs.com/zongwei" target="_blank" title="cnblogs"><i class="fab fa-cuttlefish flat-btn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">What we do is what defines us.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">一、指令重排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-as-if-serial"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 as-if-serial</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 数据依赖性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%89%E7%A7%8D%E9%87%8D%E6%8E%92%E5%BA%8F%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 三种重排序场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 重排序对多线程的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%A6%81%E6%AD%A2%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 禁止重排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM"><span class="toc-number">2.</span> <span class="toc-text">二、Java内存模型JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Happens-Before-%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Happens Before 原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%A7%84%E5%88%99%E4%B8%80%EF%BC%9A%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E5%8E%9F%E5%88%99"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 规则一：程序顺序原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%A7%84%E5%88%99%E4%BA%8C%EF%BC%9Avolatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 规则二：volatile变量规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%A7%84%E5%88%99%E4%B8%89%EF%BC%9A%E7%AE%A1%E7%A8%8B%E4%B8%AD%E9%94%81%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 规则三：管程中锁的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%A7%84%E5%88%99%E5%9B%9B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E8%A7%84%E5%88%99"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4 规则四：线程启动规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E8%A7%84%E5%88%99%E4%BA%94%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E8%A7%84%E5%88%99"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5 规则五：线程终止规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E8%A7%84%E5%88%99%E5%85%AD%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E8%A7%84%E5%88%99"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6 规则六：线程中断规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-%E8%A7%84%E5%88%99%E4%B8%83%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%BB%88%E7%BB%93%E8%A7%84%E5%88%99"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7 规则七：对象终结规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-8-%E8%A7%84%E5%88%99%E5%85%AB%EF%BC%9A%E4%BC%A0%E9%80%92%E6%80%A7%E8%A7%84%E5%88%99"><span class="toc-number">2.1.8.</span> <span class="toc-text">2.1.8 规则八：传递性规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BC%93%E5%AD%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 缓存的可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-sychronized"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 sychronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-volatile"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 内存屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E8%AF%AD%E4%B9%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">final语义中的内存屏障</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/9a537682/" title="Java并发基础2-原子操作">Java并发基础2-原子操作</a><time datetime="2022-05-19T03:18:11.562Z" title="发表于 2022-05-19 11:18:11">2022-05-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/b8e7f905/" title="Java并发基础1-指令重排序与JVM内存模型">Java并发基础1-指令重排序与JVM内存模型</a><time datetime="2022-05-18T01:16:06.990Z" title="发表于 2022-05-18 09:16:06">2022-05-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/a0ddf6ec/" title="国密算法在多语言下的适配">国密算法在多语言下的适配</a><time datetime="2022-04-28T07:27:32.889Z" title="发表于 2022-04-28 15:27:32">2022-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By ZongweiBai</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank"href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo"title="博客框架为 Hexo"alt="HEXO"></a><a style="margin-inline:5px"target="_blank"href="https://github.com/jerryc127/hexo-theme-butterfly"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender"title="主题采用 Butterfly"alt="Butterfly"></a><a style="margin-inline:5px"target="_blank"href="https://github.com/ZongweiBai/ZongweiBai.github.io"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub"title="本站项目由 GitHub 托管"alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"alt="img"title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'ZongweiBai/ZongweiBai.github.io')
  ele.setAttribute('issue-term', 'title')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?ZongweiBai";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="ZongweiBai";
            var parent_div_git = document.getElementById('about-github-calendar');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('about-github-calendar')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>