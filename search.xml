<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发基础2-原子操作</title>
      <link href="/posts/9a537682/"/>
      <url>/posts/9a537682/</url>
      
        <content type="html"><![CDATA[<p>接上文，在并发情况下，使用了<code>volatile</code>关键字，能否保证多线程情况下结果的准确性？答案是不能，验证如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="comment">//类的内部成员变量num</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">numPlusPlus</span><span class="params">()</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主方法为 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyTest</span> <span class="variable">myTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTest</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 10个线程创建出来，每个线程执行2000次num++操作</span></span><br><span class="line"><span class="comment">     * 我们知道，在字节码及底层，i++被抽象为三个操作</span></span><br><span class="line"><span class="comment">     * 即先取值，再自加，再赋值操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2000</span>; j++) &#123;</span><br><span class="line">                myTest.numPlusPlus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里规定线程数大于2，一般有GC线程以及main主线程</span></span><br><span class="line">    <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t finally num value is &quot;</span> + myTest.num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如上所示，如果volatile保证原子性，那么10个线程分别执行自加2000次操作，那么最终结果一定是20000，但是执行三次结果如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一次</span></span><br><span class="line">main  <span class="keyword">finally</span> num value is <span class="number">19003</span></span><br><span class="line"><span class="comment">//第二次</span></span><br><span class="line">main  <span class="keyword">finally</span> num value is <span class="number">18694</span></span><br><span class="line"><span class="comment">//第三次</span></span><br><span class="line">main  <span class="keyword">finally</span> num value is <span class="number">19552</span></span><br></pre></td></tr></table></figure><p>可以发现，我们num的值每次都不相同，且最后的值都没有达到20000，这是为什么呢？</p><p><strong>为什么会出现这种情况？</strong> </p><p>首先，我们要考虑到这种情况，假如线程A执行到第11行即<code>myTest.numPlusPlus();</code>方法时，线程A将从主存中读取到num的值为0，之后num的值自增为1，之后线程A挂起，线程B此时也将主存中的num值读到自己的工作内存中（此时线程A还未将自增后的num写入主存，因此线程B读到的num还是0），并将num的值自增1，之后线程B挂起，线程A继续运行将num的值写回主存（此时主存num值为1），然后线程B继续运行，也将值为1的num写回主存，最终两个线程一共执行了两次自增操作，但是主存中的结果只有一次。其根本原因在于这段代码有两个步骤：<strong>读和写，volatile只保证了读操作进行时和主存的一致性</strong>，但是未保证写操作的原子性。</p><blockquote><p>原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></blockquote><p>要解决这个问题，就要保证变量操作的原子性。</p><p>要实现Java操作的原子性，有以下几种方式：</p><h1 id="一、synchronized"><a href="#一、synchronized" class="headerlink" title="一、synchronized"></a>一、synchronized</h1><p>synchronized中文意思是同步，也称之为”同步锁“。synchronized的作用是保证在同一时刻， 被修饰的代码块或方法只会有一个线程执行，以达到保证并发安全的效果（同一时间只有一个线程运行，也就是串行执行）。</p><h2 id="1-1-synchronized的用法"><a href="#1-1-synchronized的用法" class="headerlink" title="1.1 synchronized的用法"></a>1.1 synchronized的用法</h2><p><strong>用于方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//在方法前面加上synchronized关键字表示作用于该方法</span></span><br><span class="line">    <span class="comment">//需要注意方法有两种，一种静态方法，一种非静态方法</span></span><br><span class="line">    <span class="comment">//两者区别在于，当修饰静态时候，大家都调用的是同一个。当修饰非静态方法时候，调用的是每个对象自己的那个方法，因为非静态域或方法是每个对象各自都有一份的，静态方法是所有对象公有的。</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mC</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用于代码块</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//修饰代码块的情况也有两种，这里表示对类进行同步</span></span><br><span class="line">        <span class="keyword">synchronized</span> (A.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//这里表示对当前对象进行同步，两者区别看下文</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-synchronized锁的种类"><a href="#1-2-synchronized锁的种类" class="headerlink" title="1.2 synchronized锁的种类"></a>1.2 synchronized锁的种类</h2><p><strong>类锁</strong></p><p>类锁，是用来锁类的，我们知道一个类的所有对象共享一个class对象，共享一组静态方法，类锁的作用就是使持有者可以同步地调用静态方法。当synchronized指定修饰静态方法或者class对象的时候，拿到的就是类锁，类锁是所有对象共同争抢一把。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//B中有两个方法mB和mC</span></span><br><span class="line"><span class="comment">//mB是synchronized修饰静态方法，拿到类锁</span></span><br><span class="line"><span class="comment">//mC是synchronized修饰非静态方法，拿到的也是类锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mC</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (B.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.print(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象锁</strong></p><p>对象锁，是用来对象的，虚拟机为每个的非静态方法和非静态域都分配了自己的空间，不像静态方法和静态域，是所有对象共用一组。<br>所以synchronized修饰非静态方法或者this的时候拿到的就是对象锁，对象锁是每个对象各有一把的，即同一个类如果有两个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类C中有两个方法mB和mC</span></span><br><span class="line"><span class="comment">//mB是synchronized非静态方法，拿到对象锁</span></span><br><span class="line"><span class="comment">//mC是synchronized修饰this，拿到的也是对象锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> publi <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mC</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.print(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-对象锁和类锁的使用"><a href="#1-3-对象锁和类锁的使用" class="headerlink" title="1.3 对象锁和类锁的使用"></a>1.3 对象锁和类锁的使用</h2><p><strong>对象锁</strong></p><p>下例中，两个线程调用同一个对象b的mB方法。最终结果是输出了1000次“1”之后输出了1000次“2”。可见两个线程对此方法的调用实现了同步。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//修饰非静态方法拿到对象锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修饰this拿到对象锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mB2</span><span class="params">(String name)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.print(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//线程1的调用处</span></span><br><span class="line">                    b.mB(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//线程2的调用处</span></span><br><span class="line">                    b.mB2(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类锁</strong></p><p>下面代码中对静态方法mA和mC的调用实现了同步，结果没有交替输出1和2，而是一次性输出完成后再输出的另一种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//修饰静态方法，调用取得类锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修饰class对象，调用取得静类锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mC</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (B.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.print(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    B.mB(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                B.mC(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类锁和对象锁同时存在</strong></p><p>同时存在的情况下，两者做不到同步。类锁和对象锁是两种锁。下述情况，类B的静态方法和代码块功能都是打印100个value值，但是静态方法是类锁，而代码块锁this，是对象锁。所以代码块和静态方法交替执行、交替打印，大家可复制代码自行验证。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">//静态方法，上类锁，函数功能为连续打印1000个value值，调用时会传1，所以会打印1000个1</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mB</span><span class="params">(String value)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.print(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mC</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="comment">//修饰this上对象锁，函数功能也是连续打印1000个value值，调用时会传2，所以会打印1000个2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                System.out.print(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    B.mB(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">B</span>().mC(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、原子操作"><a href="#二、原子操作" class="headerlink" title="二、原子操作"></a>二、原子操作</h1><p>原子类是java1.5开始提供的一套并发解决API，作用和锁类似，目的都是为了保证在多线程并发条件下的安全问题，但是原子类类比锁来说有两个优势</p><ul><li>锁的粒度更细，原子类可以将锁的粒度细化到变量级别， 但是通常锁的粒度都是好几行代码</li><li>效率更高，但是在线程高度竞争的情况下效率会降低</li></ul><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/20220519144116.png" alt="image-20220519144115835"></p><p>Atomic类的使用很简单，这里不再赘述，下面谈一下Atomic是如何实现的。</p><h2 id="2-1-CAS-操作"><a href="#2-1-CAS-操作" class="headerlink" title="2.1 CAS 操作"></a>2.1 CAS 操作</h2><p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁（后面的章节还会谈到锁）。</p><p>锁机制存在以下问题：</p><blockquote><ol><li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li><li>一个线程持有锁会导致其它所有需要此锁的线程挂起。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</li></ol></blockquote><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><p>上面的乐观锁用到的机制就是<strong>CAS</strong>，Compare and Swap。</p><p>一个标准的CAS包含三个操作： </p><ul><li>将要操作的内存地址M。 </li><li>现有的变量A。 </li><li>新的需要存储的变量B。 </li></ul><p>CAS将会先比较A和M中存储的值是否一致，一致则表示其他线程未对该变量进行修改，则将其替换为B。 否则不做任何操作。 使用CAS可以不用阻塞其他的线程，但是我们需要自己处理好当更新失败的情况下的业务逻辑处理情况。</p><h2 id="2-2-非阻塞算法-（nonblocking-algorithms）"><a href="#2-2-非阻塞算法-（nonblocking-algorithms）" class="headerlink" title="2.2 非阻塞算法 （nonblocking algorithms）"></a>2.2 非阻塞算法 （nonblocking algorithms）</h2><blockquote><p>一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p></blockquote><p>现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 <code>compareAndSet()</code> 就用这些代替了锁定。</p><p>拿出AtomicInteger来研究在没有锁的情况下是如何做到数据正确性的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure><p>首先毫无疑问，在没有锁的机制下可能需要借助volatile原语，保证线程间的数据是可见的（共享的）。</p><p>这样才获取变量的值的时候才能直接读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来看看 ++i 是怎么做到的。  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里采用了CAS操作，每次从内存中读取数据然后将此数据和+1后的结果进行CAS操作，如果成功就返回结果，否则重试直到成功为止。</p><p>而<code>compareAndSet</code>利用JNI来完成CPU指令的操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的过程就是这样子的，利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。</p><p>而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。参考资料的文章中介绍了如果利用CAS构建非阻塞计数器、队列等数据结构。</p><p><strong>CAS看起来很爽，但是会导致“ABA问题”。</strong></p><p>CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><code>AtomicStampedReference</code>通过引入时间戳来解决了ABA问题。每次要更新值的时候，需要额外传入oldStamp和newStamp。将对象和stamp包装成了一个Pair对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jaychou&quot;</span>,<span class="number">24</span>);</span><br><span class="line">AtomicStampedReference&lt;User&gt; userAtomicStampedReference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(user,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;jay&quot;</span>,<span class="number">222</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldStamp1</span> <span class="operator">=</span> userAtomicStampedReference.getStamp();</span><br><span class="line">    <span class="type">int</span>[] stamp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="type">User</span> <span class="variable">oldUser</span> <span class="operator">=</span> userAtomicStampedReference.get(stamp);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> userAtomicStampedReference.compareAndSet(oldUser,user1,stamp[<span class="number">0</span>],stamp[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(userAtomicStampedReference.get(s));</span><br><span class="line">System.out.println(s[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h1><p>在 JDK 1.5 之前共享对象的协调机制只有 synchronized 和 volatile，在 JDK 1.5 中增加了新的机制 ReentrantLock，该机制的诞生并不是为了替代 synchronized，而是在 synchronized 不适用的情况下，提供一种可以选择的高级功能。</p><p>ReentrantLock 是 Lock 的默认实现方式之一，它是基于 AQS（Abstract Queued Synchronizer，队列同步器）实现的，它默认是通过非公平锁实现的，在它的内部有一个 state 的状态字段用于表示锁是否被占用，如果是 0 则表示锁未被占用，此时线程就可以把 state 改为 1，并成功获得锁，而其他未获得锁的线程只能去排队等待获取锁资源。<br>ReentrantLock 中的 lock() 是通过 sync.lock() 实现的，但 Sync 类中的 lock() 是一个抽象方法，需要子类 NonfairSync 或 FairSync 去实现，NonfairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 将当前线程设置为此锁的持有者</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 中的 lock() 源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出非公平锁比公平锁只是多了一行 compareAndSetState 方法，该方法是尝试将 state 值由 0 置换为 1，如果设置成功的话，则说明当前没有其他线程持有该锁，不用再去排队了，可直接占用该锁，否则，则需要通过 acquire 方法去排队。</p><p>synchronized 和 ReentrantLock 都提供了锁的功能，具备互斥性和不可见性。在 JDK 1.5 中 synchronized 的性能远远低于 ReentrantLock，但在 JDK 1.6 之后 synchronized 的性能略低于 ReentrantLock，它的区别如下：</p><ul><li>synchronized 是 JVM 隐式实现的，而 ReentrantLock 是 Java 语言提供的 API；</li><li>ReentrantLock 可设置为公平锁，而 synchronized 却不行；</li><li>ReentrantLock 只能修饰代码块，而 synchronized 可以用于修饰方法、修饰代码块等；</li><li>ReentrantLock 需要手动加锁和释放锁，如果忘记释放锁，则会造成资源被永久占用，而 synchronized 无需手动释放锁；</li><li>ReentrantLock 可以知道是否成功获得了锁，而 synchronized 却不行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发基础1-指令重排序与JVM内存模型</title>
      <link href="/posts/b8e7f905/"/>
      <url>/posts/b8e7f905/</url>
      
        <content type="html"><![CDATA[<p>并发是Java重要的一个知识点，在编码的过程中，经常会遇见这样一种场景：单线程下的代码在多线程下出现了和预期不一样的结果，其中一个原因就是JVM对我们的代码做了指令重排序的优化。</p><h1 id="一、指令重排序"><a href="#一、指令重排序" class="headerlink" title="一、指令重排序"></a>一、指令重排序</h1><p><strong>为什么需要对指令进行重排序？</strong>其目的就是对我们的代码进行运行上的优化，我们会默认期望这些语句的实际运行顺序和写的代码顺序一致。但实际上，编译器、JVM 或者 CPU 都有可能出于优化等目的，对于实际指令执行的顺序进行调整。</p><p>指令重排序是JVM为了优化指令，提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p><h2 id="1-1-as-if-serial"><a href="#1-1-as-if-serial" class="headerlink" title="1.1 as-if-serial"></a>1.1 as-if-serial</h2><p>指令重排序必须满足<code>as-if-serial</code>语义：<strong>即无论怎么样重排序，都不能够改变单线程程序运行的结果</strong>。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>经过指令重排序后，可能被优化成以下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>1和2的执行顺序被调换，但是不会影响单线程下，执行3获得的结果。</p><h2 id="1-2-数据依赖性"><a href="#1-2-数据依赖性" class="headerlink" title="1.2 数据依赖性"></a>1.2 数据依赖性</h2><blockquote><p>数据依赖性：如果两个操作同时访问一个变量，且这两个操作中有一个为写操作，那么这两个操作具有数据依赖性。</p></blockquote><p>数据依赖性：<strong>即无论怎么样重排序，都不能够改变具有数据依赖性的两个操作的执行顺序</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> a * <span class="number">2.0</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a * b;</span><br></pre></td></tr></table></figure><p>例如上述代码，不会被重排序调换1和2的位置，因为这两条指令都对a进行了操作，且1对a进行了写操作，存在数据依赖性。</p><h2 id="1-3-三种重排序场景"><a href="#1-3-三种重排序场景" class="headerlink" title="1.3 三种重排序场景"></a>1.3 三种重排序场景</h2><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172343124.webp" alt="img"></p><p><strong>1、编译器重排序</strong> </p><p>针对程序代码语而言，编译器可以在不改变<strong>单线程</strong>程序语义的情况下，可以对代码语句顺序进行调整重新排序。</p><p><strong>2、指令集并行的重排序</strong></p><p>这个是针对于CPU指令级别来说的，处理器采用了指令集并行技术来讲多条指令重叠执行，如果不存在数据依赖性，处理器可以改变主句对应的机器指令执行顺序。</p><p><strong>3、内存重排序</strong> </p><p>内存系统内不存在真正的重排序，但是内存会带来看上去和重排序一样的效果，所以这里的“重排序”打了双引号。由于内存有缓存的存在，在 JMM 里表现为主存和本地内存，而主存和本地内存的内容可能不一致，所以这也会导致程序表现出乱序的行为。从表面结果上来看好像指令的顺序被改变了，内存重排序其实是造成可见性问题的主要原因所在。</p><p>举个例子，线程 1 修改了 a 的值，但是修改后没有来得及把新结果写回主存或者线程 2 没来得及读到最新的值，所以线程 2 看不到刚才线程 1 对 a 的修改（<strong>也就是说读写操作并不是原子的，这也就是volatile关键字无法保证多线程情况下一致性的原因</strong>），此时线程 2 看到的 a 还是等于初始值。但是线程 2 却可能看到线程 1 修改 a  之后的代码执行效果，表面上看起来像是发生了重顺序。</p><h2 id="1-4-重排序对多线程的影响"><a href="#1-4-重排序对多线程的影响" class="headerlink" title="1.4 重排序对多线程的影响"></a>1.4 重排序对多线程的影响</h2><p>单线程的重排序很简单，因为可以通过语义分析就能知道前后代码的依赖性，但是多线程就不一样了，多线程环境里编译器和CPU指令优化根本无法识别多个线程之间存在的数据依赖性，比如说下面的程序代码如果两个方法在两个不同的线程里面调用就可能出现问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br><span class="line">    flag=<span class="literal">true</span>;   <span class="comment">//语句2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面代码，如果程序代码运行都是按顺序的，那么getValue()  中打印的value值必定是等于8的，不过如果init(）方法经过了指令重排序，那么结果就不一定了。根据as-if-serial  原则，init()方法是允许进行指令重排序，因为语句1和语句2之间没有依赖关系。 进行重排序后代码执行顺序可能如下。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag=<span class="literal">true</span>;   <span class="comment">//语句2  </span></span><br><span class="line">value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br></pre></td></tr></table></figure><p>如果init()方法经过了指令重排序后，这个时候两个线程分别调用 init()和getValue()方法，那么就有可能出现下图的情况，导致最终打印出来的value数据等于0。</p><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172328913.png" alt="image-20220517232835679"></p><h2 id="1-5-禁止重排序"><a href="#1-5-禁止重排序" class="headerlink" title="1.5 禁止重排序"></a>1.5 禁止重排序</h2><p>在复杂的多线程环境下，编译器和处理器是根本无法通过语义分析来知道代码指令的依赖关系的，所以这个问题只交给能写代码的人才能清楚的知道，这个时候编写代码的人就需要通过一种方式显示的告诉编译器和处理器哪些地方是存在逻辑依赖的，这些地方不能进行重排序。</p><p>所以在编译器层面和CPU层面都提供了一套内存屏障来禁止重排序的指令，不过在Java中为了简化开发人员的工作，避免开发人员需要对底层的系统原理的深度理解，所以封装了一套规范，把这些复杂的指令操作与开发人员隔离开来，这就是我们常说的Java 内存模型(JMM)，JMM定义了几个happens  before原则来指导并发程序编写的正确性。程序员可以通过Volatile、synchronized、final几个关键字告诉编译器和处理器哪些地方是不允许进行重排序的。</p><h1 id="二、Java内存模型JMM"><a href="#二、Java内存模型JMM" class="headerlink" title="二、Java内存模型JMM"></a>二、Java内存模型JMM</h1><p>Java 内存模型实际上就是规范了 JVM 如何提供按需禁用缓存和重排序优化的方法。其核心就包括volatile、synchronized 和  final 三个关键字，以及几项Happens-Before 规则。有了JMM  作为java的开发人员只需要使用几个关键字(sychronized，volatile，final)，并且理解几个happens  before规则，就能根据自己的需要来禁用缓存优化和指令重排序，从而避免并发问题。</p><h2 id="2-1-Happens-Before-原则"><a href="#2-1-Happens-Before-原则" class="headerlink" title="2.1 Happens Before 原则"></a>2.1 Happens Before 原则</h2><p>作为开发人员来说，如果不想太深入底层去了解计算机底层的原理，又想编写出正确的并发程序，那么就必须对Happens Before原则加以理解，理解这些原则才能帮助我们避免并发程序的BUG，在出现并发问题后也能马上发现问题的所在。Happens  Before原则就像我们的JAVA并发程序的开发手册，这个手册中一共包含了X条的原则，下面我们来一一了解。</p><blockquote><ol><li>as-if-serial语义保证了<strong>单线程</strong>内程序的执行结果不会被重排序改变。</li><li>happens-before关系保证了<strong>正确同步的多线程程序</strong>的执行结果不会被改变。</li><li>happens-before不是规范，而是一种指导思想，我们需要使用各种手段如加锁等实现happens-before，这样才能保证并发环境下结果的正确性。</li></ol></blockquote><h3 id="2-1-1-规则一：程序顺序原则"><a href="#2-1-1-规则一：程序顺序原则" class="headerlink" title="2.1.1 规则一：程序顺序原则"></a>2.1.1 规则一：程序顺序原则</h3><p>定义：在一个线程中，按照程序代码的执行流顺序，先执行的操作happen—before后执行的操作。</p><p>说明：这个规则的意思就是 前面的写操作对于后面的读操作来说是可见的，按下面的代码来说，x=1的写入对于flag=true是可见的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    x=<span class="number">1</span>;       <span class="comment">//这里的值对于后续操作可见</span></span><br><span class="line">    flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-规则二：volatile变量规则"><a href="#2-1-2-规则二：volatile变量规则" class="headerlink" title="2.1.2 规则二：volatile变量规则"></a>2.1.2 规则二：volatile变量规则</h3><p>定义：对一个volatile变量的写操作happen—before后面对该变量的读操作。</p><p>说明：这个规则的是说，如果一个线程先修改了volatile的变量，那么这个操作对于后续其他线程对这个volatile变量读操作是可见的。 如下代码，线程1调用write() 修改了共享变量 x，然后线程2调用了read() 读取x，这个时候线程1 操作  x=1  对于线程2是可见的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程1调用write()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2调用 read()</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-规则三：管程中锁的规则"><a href="#2-1-3-规则三：管程中锁的规则" class="headerlink" title="2.1.3 规则三：管程中锁的规则"></a>2.1.3 规则三：管程中锁的规则</h3><p>定义：一个锁的unlock(解锁)操作happen—before后面对该锁的lock(加锁)操作。</p><p>说明：如果线程1解锁了A对象，然后线程2对A进行了加锁操作，那么线程1对共享变量的所有写操作对于线程2是可见的。</p><p>这个逻辑对应到代码里面就如下,   write()方法 synchronized  代码块执行完之后（也就是对this对象的解锁操作，synchronized代码执行完自动解锁）的结果，对于 read()方法  进入synchronized 代码块(也就是对this对象的加锁操作)是可见的，也就是 代码2 会看到 x=x+1 的结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        x=x+<span class="number">1</span>;  <span class="comment">//代码1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        Systemt.out.println(x) <span class="comment">//代码2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-规则四：线程启动规则"><a href="#2-1-4-规则四：线程启动规则" class="headerlink" title="2.1.4 规则四：线程启动规则"></a>2.1.4 规则四：线程启动规则</h3><p>定义：Thread.start()方法happen—before调用用start的线程前的每一个操作。</p><p>说明：如果A线程调用 B线程的start()方法，那么A线程 在调用B.start()之前对共享变量的所有写操作对于B线程来说都是可见的。</p><p>如下代码，当先运行的线程为线程A，A线程先对共享变量v进行赋值，然后A线程调用B线程start()方法，那么B线程是可以看到v=10的这个操作的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">v=<span class="number">10</span>;   <span class="comment">//此操作对于线程B来说是可见的</span></span><br><span class="line">threadB.start(); <span class="comment">//当前线程调用线程B的start()方法</span></span><br></pre></td></tr></table></figure><h3 id="2-1-5-规则五：线程终止规则"><a href="#2-1-5-规则五：线程终止规则" class="headerlink" title="2.1.5 规则五：线程终止规则"></a>2.1.5 规则五：线程终止规则</h3><p>定义：线程中的所有操作都happen-before于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值等手段检测到线程已经终止执行。</p><p>说明：以join()为例，如果A线程调用B线程的Join()方法，那么当B线程的Join方法返回后，A线程可以看到B线程对共享变量的所有写操作。 以下面代码为例，当前线程调用了threadB的join()方法并返回后，线程设置x=1的操作对于当前线程是可见的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadB.start();</span><br><span class="line">    threadB.join();<span class="comment">//这个操作返回之后，threadB操作 x=1 对于当前线程是可见的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-6-规则六：线程中断规则"><a href="#2-1-6-规则六：线程中断规则" class="headerlink" title="2.1.6 规则六：线程中断规则"></a>2.1.6 规则六：线程中断规则</h3><p>定义：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。</p><p>说明：线程A调用了线程B的interrupt()方法，那么当线程B触发interrupt之后，线程A对所有共享变量的写操作对于线程B来说都是可见的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception&#123;</span><br><span class="line">    Thread threadB=<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//此处是可以看到 x=1的操作的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    threadB.start();</span><br><span class="line">    x=<span class="number">1</span>;<span class="comment">//修改共享变量</span></span><br><span class="line">    threadB.interrupt();<span class="comment">//调用threadB中断方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-7-规则七：对象终结规则"><a href="#2-1-7-规则七：对象终结规则" class="headerlink" title="2.1.7 规则七：对象终结规则"></a>2.1.7 规则七：对象终结规则</h3><p>定义：一个对象的初始化完成（构造函数执行结束）happen—before它的<code>finalize()</code>方法的开始。</p><p>说明：调用对象<code>finalize()</code>方法时，对象初始化完成的任意操作，对于调用<code>finalize()</code>线程来说都是可见的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception,Throwable&#123;</span><br><span class="line">        Test test=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        test.finalize(); <span class="comment">//x = 8操作对于此线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-8-规则八：传递性规则"><a href="#2-1-8-规则八：传递性规则" class="headerlink" title="2.1.8 规则八：传递性规则"></a>2.1.8 规则八：传递性规则</h3><p>定义：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。</p><p>传递性规则要与其他规则组合理解，以volatile规则+传递性规则为例，下面代码中</p><p>1、因为  y=1 hanpen-before  x=2（顺序性原则）</p><p>2、而 x = 2 hanpen-before x = 3（volatile变量 规则）; </p><p>3、 而x = 3又 hanpen-before  z=4（顺序性原则）。</p><p>4、所以最终得出 y=1 happen-before  z=4(传递性原则);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">volatile</span>  <span class="type">int</span> y; </span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line">    x = <span class="number">2</span>; <span class="comment">//因为 y=1 hanpen-before x=2（顺序性原则） 所以y=1 对于x=2可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">3</span>;  <span class="comment">//因为  x = 2 hanpen-before x=3（volatile 规则） 所以x = 2 对于x=3可见</span></span><br><span class="line">    z=<span class="number">4</span>;  <span class="comment">//因为  y=1 hanpen-before  x=2，而 x = 2 hanpen-before x = 3;  而x = 3又 hanpen-before  z=4（顺序性原则），所以 y=1 happen-before z=4(传递性原则);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-Java内存模型"><a href="#2-2-Java内存模型" class="headerlink" title="2.2 Java内存模型"></a>2.2 Java内存模型</h2><p>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li></ul><p><strong>Java内存模型的作用是控制Java线程之间的通信，它决定了一个线程对共享变量的写入什么时候对另一个线程可见</strong>；而JVM内存模型指的是Java虚拟机运行时的内存分区。这里大家不要混淆。</p><p>Java内存模型约定线程之间共享的变量存储在主内存中，而每个线程又有自身私有的本地内存（工作内存），本地内存是Java线程直接能读/写到的区域。 </p><p><strong>两条规定:</strong></p><ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读取</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li></ul><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205172346527.png" alt="img"></p><p>可以看出，多线程工作的时候，是会从主线程中copy一份副本变量到自己的工作内存，那么如何保证其他线程修改的变量能够被自己的线程读取到，这就是一个缓存可见性的问题。</p><h2 id="2-3-缓存的可见性"><a href="#2-3-缓存的可见性" class="headerlink" title="2.3 缓存的可见性"></a>2.3 缓存的可见性</h2><blockquote><p>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。</p><p>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</p></blockquote><p> 要实现共享变量的可见性，必须保证两点：</p><ul><li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</li></ul><p>产生并发问题的一个核心的原因就是多个CPU都有各自的缓存区域，而且它们各自之间无法感知的，当一个CPU对共享数据进行修改了之后，其它CPU并不知道内容已经被修改了，还是从自己缓存里读取到旧的数据，那么其实解决这个问题的根本其实就是需要一种机制来保证一个人修改了内存数据后另外几个缓存了该共享变量的人可以感知到，那么就可以保证各个缓存之间的数据一致性了。</p><h3 id="2-3-1-sychronized"><a href="#2-3-1-sychronized" class="headerlink" title="2.3.1 sychronized"></a>2.3.1 sychronized</h3><p><strong>synchronized 底层实际上通过JVM来实现</strong>的，同一时间只能有一个线程去执行synchronized 中的代码块。</p><p>既然<strong>同一时间只有一个线程去运行里面的代码</strong>，那么<strong>这个操作就是不能被其它线程打断的，所以这里天然就具有原子性了。</strong>自然，线程对变量的修改也会被其他线程读取到，可以这里是将并发强行转为了串行。</p><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205180001980.png" alt="image-20220518000131882"></p><h3 id="2-3-2-volatile"><a href="#2-3-2-volatile" class="headerlink" title="2.3.2 volatile"></a>2.3.2 volatile</h3><p>volatile起到了如下的作用</p><ol><li>在对变量进行写入时，会先写入到本地内存然后立即刷新到主内存中；在对变量读取时，直接从主内存读取。</li><li>volatile标识的共享变量不会被指令重排序</li></ol><p><img src="https://raw.githubusercontent.com/ZongweiBai/note-image/main/note/202205180008126.png" alt="img"></p><p>为了达到这两个目的，volatile做了两件事情：</p><ol><li>禁止编译器的优化和重排</li><li>通过内存屏障限制处理器重排</li></ol><h3 id="2-3-3-内存屏障"><a href="#2-3-3-内存屏障" class="headerlink" title="2.3.3 内存屏障"></a>2.3.3 内存屏障</h3><p>无论是sychronized还是volatile，都是通过内存屏障保证了缓存的可见性。</p><p><strong>为什么会有内存屏障？</strong></p><ul><li>每个CPU都会有自己的缓存(有的甚至有三级缓存)，缓存的目的就是为了提高性能，避免每次都要向内存取，但是这样的弊端也是很明显：不能实时和内存发生信息交换，分在不同CPU执行的不同线程对同一变量的缓存值不同。</li><li>用Volatile关键字修饰变量可以解决上述问题，Volatile通过<strong>内存屏障</strong>来实现，内存屏障是硬件层的概念，不同的硬件平台实现内存屏障的手段并不是一样的，java通过屏蔽这些差异，统一由jvm来生成<strong>内存屏障指令</strong>。</li></ul><p><strong>内存屏障分为两种</strong></p><ul><li>Load Barrier 读屏障</li><li>Store Barrier 写屏障</li></ul><p><strong>内存屏障的两个作用</strong></p><ul><li>阻止屏障两侧的指令重排序</li><li>写的时候，强制把缓冲区/高速缓存中的数据写回主内存，并让缓冲中的数据失效；读的时候直接从主内存中读取对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据</li></ul><p>对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</p><p>java的内存屏障通常所谓的四种即LoadLoad,StoreStore,LoadStore,StoreLoad实际上也是上述两种的组合，完成一系列的屏障和数据同步功能</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad;  Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。<strong>它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</strong>。</li></ul><p><strong>volatile与内存屏障</strong></p><p> volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：</p><blockquote><p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；</p><p>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；</p></blockquote><p>由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。</p><h4 id="final语义中的内存屏障"><a href="#final语义中的内存屏障" class="headerlink" title="final语义中的内存屏障"></a>final语义中的内存屏障</h4><p>对于final域，编译器和CPU会遵循两个排序规则：</p><blockquote><ol><li><p>新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）</p></li><li><p>初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）</p></li></ol></blockquote><p>总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：</p><p>写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程CPU可见，并阻止重排序。</p><p>读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。</p><p>X86处理器中，由于CPU不会对写-写操作进行重排序，所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国密算法在多语言下的适配</title>
      <link href="/posts/a0ddf6ec/"/>
      <url>/posts/a0ddf6ec/</url>
      
        <content type="html"><![CDATA[<h1 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h1><p>本文中用到的加密算法实现开源项目如下：</p><p>java：<a href="https://github.com/ZZMarquis/gmhelper">https://github.com/ZZMarquis/gmhelper</a></p><p>golang：<a href="https://github.com/Hyperledger-TWGC/ccs-gm">https://github.com/Hyperledger-TWGC/ccs-gm</a></p><p>js：<a href="https://github.com/JuneAndGreen/sm-crypto">https://github.com/JuneAndGreen/sm-crypto</a></p><h1 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h1><p>SM2的调试较为复杂，需要注意的点有两个：1、密钥对的生成；2、JS加解密时的特殊处理。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>经过测试，只有golang生成的密钥对才能在golang、java和js三端通用，生成方式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">iniSk, _ := sm2.GenerateKey(rand.Reader)</span><br><span class="line">iniPk := iniSk.PublicKey</span><br><span class="line"></span><br><span class="line">pemSk, err := PrivateKeyToPEM(iniSk, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;private key to pem error %t&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;pem私钥：%s&quot;</span>, <span class="type">string</span>(pemSk))</span><br><span class="line"></span><br><span class="line">pemPk, err := PublicKeyToPEM(&amp;iniPk, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;public key to pem error %t&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;pem公钥：%s&quot;</span>, <span class="type">string</span>(pemPk))</span><br></pre></td></tr></table></figure><p>生成的PEM密钥可以直接在golang和java中使用，但是js的密钥还需要做一次转换，这里使用Java做转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">privatePem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem私钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] pkcs8PrivateKey = BCECUtil.convertECPrivateKeyPEMToPKCS8(privatePem);</span><br><span class="line">System.out.println(HexUtil.getHexString(pkcs8PrivateKey));</span><br><span class="line"></span><br><span class="line"><span class="type">BCECPrivateKey</span> <span class="variable">ecpPrivateKey</span> <span class="operator">=</span> BCECUtil.convertPKCS8ToECPrivateKey(pkcs8PrivateKey);</span><br><span class="line"><span class="type">ECPrivateKeyParameters</span> <span class="variable">privateKeyParameters</span> <span class="operator">=</span> BCECUtil.convertPrivateKeyToParameters(ecpPrivateKey);</span><br><span class="line">System.out.println(<span class="string">&quot;JS私钥: &quot;</span> + HexUtil.byteToHex(privateKeyParameters.getD().toByteArray()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">publicPem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem公钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] x509PublicKey = BCECUtil.convertECPublicKeyPEMToX509(publicPem);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> HexUtil.getHexString(x509PublicKey);</span><br><span class="line">System.out.println(publicKey);</span><br><span class="line"></span><br><span class="line"><span class="type">BCECPublicKey</span> <span class="variable">bcecPublicKey</span> <span class="operator">=</span> BCECUtil.convertX509ToECPublicKey(x509PublicKey);</span><br><span class="line"><span class="type">ECPublicKeyParameters</span> <span class="variable">publicKeyParameter</span> <span class="operator">=</span> BCECUtil.convertPublicKeyToParameters(bcecPublicKey);</span><br><span class="line">System.out.println(<span class="string">&quot;JS公钥: &quot;</span> + HexUtil.byteToHex(publicKeyParameter.getQ().getEncoded(<span class="literal">false</span>)));</span><br></pre></td></tr></table></figure><p>java的算法实现中没有给出 <code>HexUtil</code>的实现，这里贴出我这里的实现：</p><p><a href="https://github.com/ZongweiBai/spring-boot-in-action/blob/master/spring-boot-netty-server/src/main/java/com/github/baymin/netty/util/HexUtil.java">HexUtil</a></p><h2 id="golang加解密"><a href="#golang加解密" class="headerlink" title="golang加解密"></a>golang加解密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试sm2的加密和解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEncryptAndDecrypt</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    pempk := <span class="string">`这里填上文生成的pem公钥`</span></span><br><span class="line">    normalPk, err := utils.PEMtoPublicKey([]<span class="type">byte</span>(pempk), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pemSk := <span class="string">`这里填上文生成的pem私钥`</span></span><br><span class="line">    normalSk, err := utils.PEMtoPrivateKey([]<span class="type">byte</span>(pemSk), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg := []<span class="type">byte</span>(<span class="string">&quot;helloword123123!&quot;</span>)</span><br><span class="line">    <span class="comment">//test encryption</span></span><br><span class="line">    cipher, err := sm2.Encrypt(rand.Reader, normalPk, msg)</span><br><span class="line">    fmt.Println(<span class="string">&quot;===================================================&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;加密后字符串：&quot;</span>, hex.EncodeToString(cipher))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;===================================================&quot;</span>)</span><br><span class="line">    res, err := sm2.Decrypt(cipher, normalSk)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;解密失败:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;解密后字符串：&quot;</span>, <span class="type">string</span>(res))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加解密"><a href="#java加解密" class="headerlink" title="java加解密"></a>java加解密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">publicPem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem公钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] x509PublicKey = BCECUtil.convertECPublicKeyPEMToX509(publicPem);</span><br><span class="line"><span class="type">BCECPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> BCECUtil.convertX509ToECPublicKey(x509PublicKey);</span><br><span class="line"><span class="type">byte</span>[] cipherText = SM2Util.encrypt(publicKey, PLAIN_TEXT.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">System.out.println(<span class="string">&quot;加密后密文：&quot;</span>+HexUtil.getHexString(cipherText));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">privatePem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem私钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] pkcs8PrivateKey = BCECUtil.convertECPrivateKeyPEMToPKCS8(privatePem);</span><br><span class="line"><span class="type">BCECPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> BCECUtil.convertPKCS8ToECPrivateKey(pkcs8PrivateKey);</span><br><span class="line"><span class="type">byte</span>[] plainText = SM2Util.decrypt(privateKey, HexUtil.hexToByte(<span class="string">&quot;这里填加密后密文&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;解密后明文：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(plainText));</span><br></pre></td></tr></table></figure><h2 id="js加解密"><a href="#js加解密" class="headerlink" title="js加解密"></a>js加解密</h2><blockquote><p>注意：</p><p>JS生成的密文必须加前缀“04”才能被golang和java正确解密</p><p>golang和java生成的密文一定要去除前缀“04”,再将密文全部转为小写字母后方可正确解密</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sm2 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm2</span></span><br><span class="line"></span><br><span class="line">encryptData = sm2.<span class="title function_">doEncrypt</span>(msgString, publicKey, cipherMode)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加密后密文:&#x27;</span>, encryptData)</span><br><span class="line"><span class="comment">// 这里需要注意，js生成的密文需要加前缀&quot;04&quot;后才能被golang和java正确解密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意，golang和java生成的密文一定要去除前缀“04”,再将密文全部转为小写字母后方可正确解密</span></span><br><span class="line">encryptData = <span class="string">&#x27;加密后密文&#x27;</span></span><br><span class="line">decryptData = sm2.<span class="title function_">doDecrypt</span>(encryptData, privateKey, cipherMode)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;解密后明文&#x27;</span>, decryptData)</span><br></pre></td></tr></table></figure><h1 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h1><p>SM3的调试比较简单，下面只列出各个语言的调用方法。</p><blockquote><p>每种语言生成的密文会有大小写的差异，实际使用时可以忽略大小写进行对比。</p></blockquote><h2 id="golang加密"><a href="#golang加密" class="headerlink" title="golang加密"></a>golang加密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSM3HashWithJava</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    hash := sm3.New()</span><br><span class="line">    hash.Write([]<span class="type">byte</span>(<span class="string">&quot;helloword!sm3&quot;</span>))</span><br><span class="line">    hashed := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;SM3加密密文: &quot;</span>, hex.EncodeToString(hashed))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加密"><a href="#java加密" class="headerlink" title="java加密"></a>java加密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] hashed = SM3Util.hash(PLAIN_TEXT.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(hashed));</span><br><span class="line">    System.out.println(HexUtil.getHexString(hashed));</span><br><span class="line">    SM3Util.verify(PLAIN_TEXT.getBytes(StandardCharsets.UTF_8), hashed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js加密"><a href="#js加密" class="headerlink" title="js加密"></a>js加密</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">msgString = <span class="string">&#x27;helloword!sm3&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sm3 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm3</span></span><br><span class="line">hashData = <span class="title function_">sm3</span>(msgString) <span class="comment">// 杂凑hashData</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【hashData】&#x27;</span>, hashData)</span><br></pre></td></tr></table></figure><h1 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h1><p>SM4的调试也比较简单，只需要注意key的生成和js加密key的特殊处理</p><h2 id="golang加解密-1"><a href="#golang加解密-1" class="headerlink" title="golang加解密"></a>golang加解密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSM4</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    key := []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    msg := []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef012345678&quot;</span>)</span><br><span class="line">    encMsg, err := sm4.Sm4Ecb(key, msg, sm4.ENC)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 enc error:%s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;加密后的密文：&quot;</span>, hex.EncodeToString(encMsg))</span><br><span class="line"></span><br><span class="line">    encMsg, err = hex.DecodeString(<span class="string">&quot;13278C63B7305E3C131CDBBBE6F59B86A6B8937FE1E2B336779FE4DB0537E750&quot;</span>)</span><br><span class="line">    dec, err := sm4.Sm4Ecb(key, encMsg, sm4.DEC)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 dec error:%s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;解密后的明文：&quot;</span>, <span class="type">string</span>(dec))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !bytes.Equal(msg, dec) &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 self enc and dec failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加解密-1"><a href="#java加解密-1" class="headerlink" title="java加解密"></a>java加解密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testECBPadding</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] key = <span class="string">&quot;0123456789abcdef&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里需要注意，16进制加密key用于js端</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16进制加密key: &quot;</span> + HexUtil.byteToHex(key));</span><br><span class="line">    System.out.println(<span class="string">&quot;加密key: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(key));</span><br><span class="line">    <span class="type">byte</span>[] data = <span class="string">&quot;0123456789abcdef012345678&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] cipherText = SM4Util.encrypt_ECB_Padding(key, data);</span><br><span class="line">    System.out.println(<span class="string">&quot;SM4 ECB Padding encrypt result: &quot;</span> + HexUtil.byteToHex(cipherText));</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] decryptedData = SM4Util.decrypt_ECB_Padding(key, cipherText);</span><br><span class="line">    System.out.println(<span class="string">&quot;SM4 ECB Padding decrypt result: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decryptedData));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decryptedData));</span><br><span class="line">    <span class="keyword">if</span> (!Arrays.equals(decryptedData, data)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加解密失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js加解密-1"><a href="#js加解密-1" class="headerlink" title="js加解密"></a>js加解密</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sm4 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意，一定要使用上文java测试类中生成的16进制加密key</span></span><br><span class="line">key = <span class="string">&#x27;30313233343536373839616263646566&#x27;</span> </span><br><span class="line">msgString = <span class="string">&#x27;0123456789abcdef012345678&#x27;</span></span><br><span class="line"></span><br><span class="line">encryptData = sm4.<span class="title function_">encrypt</span>(msgString, key) <span class="comment">// 加密，默认输出 16 进制字符串，默认使用 pkcs#5 填充</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【encryptData】&#x27;</span>, encryptData)</span><br><span class="line">decryptData = sm4.<span class="title function_">decrypt</span>(encryptData, key) <span class="comment">// 解密，默认输出 utf8 字符串，默认使用 pkcs#5 填充</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【decryptData】&#x27;</span>, decryptData)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 国密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> 国密 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
