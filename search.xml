<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>国密算法在多语言下的适配</title>
      <link href="/posts/a0ddf6ec/"/>
      <url>/posts/a0ddf6ec/</url>
      
        <content type="html"><![CDATA[<h1 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h1><p>本文中用到的加密算法实现开源项目如下：</p><p>java：<a href="https://github.com/ZZMarquis/gmhelper">https://github.com/ZZMarquis/gmhelper</a></p><p>golang：<a href="https://github.com/Hyperledger-TWGC/ccs-gm">https://github.com/Hyperledger-TWGC/ccs-gm</a></p><p>js：<a href="https://github.com/JuneAndGreen/sm-crypto">https://github.com/JuneAndGreen/sm-crypto</a></p><h1 id="SM2"><a href="#SM2" class="headerlink" title="SM2"></a>SM2</h1><p>SM2的调试较为复杂，需要注意的点有两个：1、密钥对的生成；2、JS加解密时的特殊处理。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>经过测试，只有golang生成的密钥对才能在golang、java和js三端通用，生成方式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">iniSk, _ := sm2.GenerateKey(rand.Reader)</span><br><span class="line">iniPk := iniSk.PublicKey</span><br><span class="line"></span><br><span class="line">pemSk, err := PrivateKeyToPEM(iniSk, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;private key to pem error %t&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;pem私钥：%s&quot;</span>, <span class="type">string</span>(pemSk))</span><br><span class="line"></span><br><span class="line">pemPk, err := PublicKeyToPEM(&amp;iniPk, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    t.Errorf(<span class="string">&quot;public key to pem error %t&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;pem公钥：%s&quot;</span>, <span class="type">string</span>(pemPk))</span><br></pre></td></tr></table></figure><p>生成的PEM密钥可以直接在golang和java中使用，但是js的密钥还需要做一次转换，这里使用Java做转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">privatePem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem私钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] pkcs8PrivateKey = BCECUtil.convertECPrivateKeyPEMToPKCS8(privatePem);</span><br><span class="line">System.out.println(HexUtil.getHexString(pkcs8PrivateKey));</span><br><span class="line"></span><br><span class="line"><span class="type">BCECPrivateKey</span> <span class="variable">ecpPrivateKey</span> <span class="operator">=</span> BCECUtil.convertPKCS8ToECPrivateKey(pkcs8PrivateKey);</span><br><span class="line"><span class="type">ECPrivateKeyParameters</span> <span class="variable">privateKeyParameters</span> <span class="operator">=</span> BCECUtil.convertPrivateKeyToParameters(ecpPrivateKey);</span><br><span class="line">System.out.println(<span class="string">&quot;JS私钥: &quot;</span> + HexUtil.byteToHex(privateKeyParameters.getD().toByteArray()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">publicPem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem公钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] x509PublicKey = BCECUtil.convertECPublicKeyPEMToX509(publicPem);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">publicKey</span> <span class="operator">=</span> HexUtil.getHexString(x509PublicKey);</span><br><span class="line">System.out.println(publicKey);</span><br><span class="line"></span><br><span class="line"><span class="type">BCECPublicKey</span> <span class="variable">bcecPublicKey</span> <span class="operator">=</span> BCECUtil.convertX509ToECPublicKey(x509PublicKey);</span><br><span class="line"><span class="type">ECPublicKeyParameters</span> <span class="variable">publicKeyParameter</span> <span class="operator">=</span> BCECUtil.convertPublicKeyToParameters(bcecPublicKey);</span><br><span class="line">System.out.println(<span class="string">&quot;JS公钥: &quot;</span> + HexUtil.byteToHex(publicKeyParameter.getQ().getEncoded(<span class="literal">false</span>)));</span><br></pre></td></tr></table></figure><p>java的算法实现中没有给出 <code>HexUtil</code>的实现，这里贴出我这里的实现：</p><p><a href="https://github.com/ZongweiBai/spring-boot-in-action/blob/master/spring-boot-netty-server/src/main/java/com/github/baymin/netty/util/HexUtil.java">HexUtil</a></p><h2 id="golang加解密"><a href="#golang加解密" class="headerlink" title="golang加解密"></a>golang加解密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试sm2的加密和解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEncryptAndDecrypt</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    pempk := <span class="string">`这里填上文生成的pem公钥`</span></span><br><span class="line">    normalPk, err := utils.PEMtoPublicKey([]<span class="type">byte</span>(pempk), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pemSk := <span class="string">`这里填上文生成的pem私钥`</span></span><br><span class="line">    normalSk, err := utils.PEMtoPrivateKey([]<span class="type">byte</span>(pemSk), <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg := []<span class="type">byte</span>(<span class="string">&quot;helloword123123!&quot;</span>)</span><br><span class="line">    <span class="comment">//test encryption</span></span><br><span class="line">    cipher, err := sm2.Encrypt(rand.Reader, normalPk, msg)</span><br><span class="line">    fmt.Println(<span class="string">&quot;===================================================&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;加密后字符串：&quot;</span>, hex.EncodeToString(cipher))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;===================================================&quot;</span>)</span><br><span class="line">    res, err := sm2.Decrypt(cipher, normalSk)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;解密失败:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;解密后字符串：&quot;</span>, <span class="type">string</span>(res))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加解密"><a href="#java加解密" class="headerlink" title="java加解密"></a>java加解密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">publicPem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem公钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] x509PublicKey = BCECUtil.convertECPublicKeyPEMToX509(publicPem);</span><br><span class="line"><span class="type">BCECPublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> BCECUtil.convertX509ToECPublicKey(x509PublicKey);</span><br><span class="line"><span class="type">byte</span>[] cipherText = SM2Util.encrypt(publicKey, PLAIN_TEXT.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">System.out.println(<span class="string">&quot;加密后密文：&quot;</span>+HexUtil.getHexString(cipherText));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">privatePem</span> <span class="operator">=</span> <span class="string">&quot;这里填上文生成的pem私钥&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] pkcs8PrivateKey = BCECUtil.convertECPrivateKeyPEMToPKCS8(privatePem);</span><br><span class="line"><span class="type">BCECPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> BCECUtil.convertPKCS8ToECPrivateKey(pkcs8PrivateKey);</span><br><span class="line"><span class="type">byte</span>[] plainText = SM2Util.decrypt(privateKey, HexUtil.hexToByte(<span class="string">&quot;这里填加密后密文&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;解密后明文：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(plainText));</span><br></pre></td></tr></table></figure><h2 id="js加解密"><a href="#js加解密" class="headerlink" title="js加解密"></a>js加解密</h2><blockquote><p>注意：</p><p>JS生成的密文必须加前缀“04”才能被golang和java正确解密</p><p>golang和java生成的密文一定要去除前缀“04”,再将密文全部转为小写字母后方可正确解密</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sm2 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm2</span></span><br><span class="line"></span><br><span class="line">encryptData = sm2.<span class="title function_">doEncrypt</span>(msgString, publicKey, cipherMode)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;加密后密文:&#x27;</span>, encryptData)</span><br><span class="line"><span class="comment">// 这里需要注意，js生成的密文需要加前缀&quot;04&quot;后才能被golang和java正确解密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意，golang和java生成的密文一定要去除前缀“04”,再将密文全部转为小写字母后方可正确解密</span></span><br><span class="line">encryptData = <span class="string">&#x27;加密后密文&#x27;</span></span><br><span class="line">decryptData = sm2.<span class="title function_">doDecrypt</span>(encryptData, privateKey, cipherMode)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;解密后明文&#x27;</span>, decryptData)</span><br></pre></td></tr></table></figure><h1 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h1><p>SM3的调试比较简单，下面只列出各个语言的调用方法。</p><blockquote><p>每种语言生成的密文会有大小写的差异，实际使用时可以忽略大小写进行对比。</p></blockquote><h2 id="golang加密"><a href="#golang加密" class="headerlink" title="golang加密"></a>golang加密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSM3HashWithJava</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    hash := sm3.New()</span><br><span class="line">    hash.Write([]<span class="type">byte</span>(<span class="string">&quot;helloword!sm3&quot;</span>))</span><br><span class="line">    hashed := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;SM3加密密文: &quot;</span>, hex.EncodeToString(hashed))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加密"><a href="#java加密" class="headerlink" title="java加密"></a>java加密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] hashed = SM3Util.hash(PLAIN_TEXT.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(hashed));</span><br><span class="line">    System.out.println(HexUtil.getHexString(hashed));</span><br><span class="line">    SM3Util.verify(PLAIN_TEXT.getBytes(StandardCharsets.UTF_8), hashed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js加密"><a href="#js加密" class="headerlink" title="js加密"></a>js加密</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">msgString = <span class="string">&#x27;helloword!sm3&#x27;</span></span><br><span class="line"><span class="keyword">const</span> sm3 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm3</span></span><br><span class="line">hashData = <span class="title function_">sm3</span>(msgString) <span class="comment">// 杂凑hashData</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【hashData】&#x27;</span>, hashData)</span><br></pre></td></tr></table></figure><h1 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h1><p>SM4的调试也比较简单，只需要注意key的生成和js加密key的特殊处理</p><h2 id="golang加解密-1"><a href="#golang加解密-1" class="headerlink" title="golang加解密"></a>golang加解密</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSM4</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    key := []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">    msg := []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef012345678&quot;</span>)</span><br><span class="line">    encMsg, err := sm4.Sm4Ecb(key, msg, sm4.ENC)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 enc error:%s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;加密后的密文：&quot;</span>, hex.EncodeToString(encMsg))</span><br><span class="line"></span><br><span class="line">    encMsg, err = hex.DecodeString(<span class="string">&quot;13278C63B7305E3C131CDBBBE6F59B86A6B8937FE1E2B336779FE4DB0537E750&quot;</span>)</span><br><span class="line">    dec, err := sm4.Sm4Ecb(key, encMsg, sm4.DEC)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 dec error:%s&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;解密后的明文：&quot;</span>, <span class="type">string</span>(dec))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !bytes.Equal(msg, dec) &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;sm4 self enc and dec failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java加解密-1"><a href="#java加解密-1" class="headerlink" title="java加解密"></a>java加解密</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testECBPadding</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] key = <span class="string">&quot;0123456789abcdef&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里需要注意，16进制加密key用于js端</span></span><br><span class="line">    System.out.println(<span class="string">&quot;16进制加密key: &quot;</span> + HexUtil.byteToHex(key));</span><br><span class="line">    System.out.println(<span class="string">&quot;加密key: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(key));</span><br><span class="line">    <span class="type">byte</span>[] data = <span class="string">&quot;0123456789abcdef012345678&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] cipherText = SM4Util.encrypt_ECB_Padding(key, data);</span><br><span class="line">    System.out.println(<span class="string">&quot;SM4 ECB Padding encrypt result: &quot;</span> + HexUtil.byteToHex(cipherText));</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] decryptedData = SM4Util.decrypt_ECB_Padding(key, cipherText);</span><br><span class="line">    System.out.println(<span class="string">&quot;SM4 ECB Padding decrypt result: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(decryptedData));</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decryptedData));</span><br><span class="line">    <span class="keyword">if</span> (!Arrays.equals(decryptedData, data)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加解密失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js加解密-1"><a href="#js加解密-1" class="headerlink" title="js加解密"></a>js加解密</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sm4 = <span class="built_in">require</span>(<span class="string">&#x27;sm-crypto&#x27;</span>).<span class="property">sm4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里需要注意，一定要使用上文java测试类中生成的16进制加密key</span></span><br><span class="line">key = <span class="string">&#x27;30313233343536373839616263646566&#x27;</span> </span><br><span class="line">msgString = <span class="string">&#x27;0123456789abcdef012345678&#x27;</span></span><br><span class="line"></span><br><span class="line">encryptData = sm4.<span class="title function_">encrypt</span>(msgString, key) <span class="comment">// 加密，默认输出 16 进制字符串，默认使用 pkcs#5 填充</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【encryptData】&#x27;</span>, encryptData)</span><br><span class="line">decryptData = sm4.<span class="title function_">decrypt</span>(encryptData, key) <span class="comment">// 解密，默认输出 utf8 字符串，默认使用 pkcs#5 填充</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;【decryptData】&#x27;</span>, decryptData)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 国密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
            <tag> 国密 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
